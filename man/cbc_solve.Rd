% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cbc_solve.R
\name{cbc_solve}
\alias{cbc_solve}
\title{Solve a mixed integer problem with \emph{CBC}}
\usage{
cbc_solve(
  obj,
  mat,
  row_ub = rep.int(Inf, nrow(mat)),
  row_lb = rep.int(-Inf, nrow(mat)),
  col_lb = rep.int(-Inf, ncol(mat)),
  col_ub = rep.int(Inf, ncol(mat)),
  is_integer = rep.int(FALSE, ncol(mat)),
  max = FALSE,
  cbc_args = list(),
  initial_solution = NULL
)
}
\arguments{
\item{obj}{\code{numeric} \code{vector} if coefficients to specify the
objective function. Note that arguments should have one value per decision
variable (i.e. column in \code{mat}).}

\item{mat}{matrix (i.e. \code{matrix} or \code{\link{Matrix-class}}) of
constraint coefficients. Here, each column corresponds to a different
decision variable, and each row corresponds to a different constraint.
To improve performance, it is recommended to specify the matrix using
a sparse format (see \code{\link[Matrix]{sparseMatrix}}).}

\item{row_ub}{\code{numeric} \code{vector} of upper bounds for constraints.
Note that arguments should have one value per constraint
(i.e. row in \code{mat}).
Defaults to a \code{vector} of infinity (\code{Inf}) values for each
constraint.}

\item{row_lb}{\code{numeric} \code{vector} of lower bounds for constraints.
 Note that arguments should have one value per constraint
(i.e. row in \code{mat}).
Defaults to a \code{vector} of negative infinity (\code{-Inf}) values for
each constraint.}

\item{col_lb}{\code{numeric} \code{vector} of lower bounds for decision
variables. Note that arguments should have one value per decision variable
(i.e. column in \code{mat}).
Defaults to a \code{vector} of negative infinity (\code{-Inf}) values for
each variable.}

\item{col_ub}{\code{numeric} \code{vector} of upper bounds for decision
 variables. Note that arguments should have one value per decision variable
(i.e. column in \code{mat}).
Defaults to a \code{vector} of infinity (\code{Inf}) values for each
variable.}

\item{is_integer}{\code{logical} \code{vector} indicating if (\code{TRUE})
each decision variable is integer or (\code{FALSE}) not an integer.
Note that arguments should have one value per decision variable
(i.e. column in \code{mat}).
Defaults to a \code{vector} of \code{FALSE} values for each variable
(meaning that all variables are continuous).}

\item{max}{\code{logical} (i.e. \code{TRUE} or \code{FALSE}) should the
solver aim to maximize the objective function? Defaults to \code{FALSE}.}

\item{cbc_args}{\code{list} of \code{character} \emph{CBC} arguments to customize the optimization
procedures (see \emph{CBC} parameters section for details). Defaults to
\code{list()}, such that default settings are used to generate solutions.
Note that all arguments must be supplied as a \code{character} object
(see below for examples).}

\item{initial_solution}{\code{numeric} initial values
for starting solution. Missing (\code{NA}) values can be used to indicate
that the starting value for a solution should be automatically calculated.
Note that only initial values for integer variables
(per argument to \code{is_integer}) are actually used to generate solutions.
This is due to the behavior of the \emph{CBC} solver.
Defaults to \code{NULL} such that the starting solution is automatically
generated.}
}
\value{
A \code{list} containing the solution and additional information.
Specifically, it contains the following elements:

\describe{

\item{column_solution}{\code{numeric} values of the decision variables
in the solution (same order as columns in the constraint matrix).}

\item{objective_value}{\code{numeric} objective value of the solution.}

\item{status}{\code{character} description of the optimization process
when it finished. This description is based on the result of the
following elements. For example, an \code{"optimal"} status indicates
that the optimization process finished because it found an optimal solution.
Also, if a maximum time limit was specified (using \code{cbc_args}), an
\code{"timelimit"} status indicates that the optimization process
finished because it ran out of time. Furthermore, an \code{"infeasible"}
status indicates that there is no possible solution to the specified
optimization problem. This \code{"infeasible"} status could potentially
mean that there was a mistake when constructing the input data.}

\item{is_proven_optimal}{\code{logical} indicating if the solution proven
to be optimal.}

\item{is_proven_dual_infeasible}{\code{logical} indicating if the
dual is proven to be infeasible.}

\item{is_proven_infeasible}{\code{logical} indicating if the optimization
problem is proven to be infeasible.}

\item{is_node_limit_reached}{\code{logical} indicating if the maximum
number of nodes permitted for solving the optimization problem was
reached.}

\item{is_solution_limit_reached}{\code{logical} indicating if the maximum
number of solutions (including those generated before finding the final
solution) permitted for solving the optimization problem was reached.}

\item{is_abandoned}{\code{logical} indicating if the optimization process
was abandoned part way through solving the optimization problem.}

\item{is_iteration_limit_reached}{\code{logical} indicating if the maximum
number of iterations permitted for solving the optimization problem was
reached.}

\item{is_seconds_limit_reached}{\code{logical} indicating if the maximum
number of seconds permitted for for solving the optimization problem was
reached.}

}
}
\description{
\href{https://projects.coin-or.org/Cbc}{\emph{CBC} (COIN-OR branch and cut)}
is an open-source mixed integer programming
solver (Forrest & Lougee-Heimer 2005). It is developed as part of the
\href{https://projects.coin-or.org/Cbc}{Computational Infrastructure for Operations Research (COIN-OR) project}.
By leveraging the \emph{CBC} solver, this function can be used to generate
solutions to optimization problems.
}
\section{\emph{CBC} parameters}{

Many different parameters can be specified to customize the optimization
process (see the \href{https://projects.coin-or.org/CoinBinary/export/1059/OptimizationSuite/trunk/Installer/files/doc/cbcCommandLine.pdf}{user manual} full list). Among all these parameters, some of the most useful parameters
include the following:

\describe{

\item{log}{Should information be printed during the solve process? Defaults
to \code{"1"} meaning that information will be printed to the console.
To prevent this, a value of \code{"0"} can be specified.}

\item{verbose}{The level of detail to provide when printing information
to the console. Defaults to \code{"1"} for a relatively small amount of
detail. For maximum detail, a value of \code{"15"} can be specified.}

\item{presolve}{Should the optimization process include a pre-processing
step that attempts to simplify the optimization problem? Defaults to
\code{"On"} such that this pre-processing step is performed. To disable
this step, a value of \code{"Off"} can be specified.}

\item{ratio}{Optimality gap for solving the problem. The optimization
 process will stop when the performance of the best found solution
is near enough to optimality based on this parameter. For example,
a value of 0.15 means that the optimization process will stop
when the best found solution is within 15% of the optimal solution.
Defaults to \code{"0"}, such that only an optimal solution is returned.}

\item{sec}{Maximum amount of time permitted for completing the
optimization process. Defaults to \code{"1e+100"}. Note that time is
measured based on the \code{TIMEM} parameter.}

\item{timem}{Method to measure time. Defaults to \code{"cpu"} such that
timing is measured using CPU time. To specify that time should be
measured based on overall time elapsed (e.g. based on a wall clock),
a value of \code{"elapsed"} can be specified.}

\item{threads}{Number of threads to use for solving the optimization
problem. For example, a value of \code{"4"} indicates that four
threads should be used. Defaults to \code{"0"}, such that the number of
threads is automatically determined.}

\item{maxso}{Maximum number of solutions permitted to examine during the
optimization process. For example, a value of \code{"1"} can be used
to obtain the first feasible solution.}

}
}

\examples{
\dontrun{
# Mathematically define a mixed integer programming problem
## maximize:
##   1 * x + 2 * y + 0.5 * z (eqn 1a)
## subject to:
##   x + y <= 1              (eqn 1b)
##   3 * x + 4 * z >= 5      (eqn 1c)
##   z = 4                   (eqn 1d)
##  0 <= x <= 10             (eqn 1e)
##  0 <= y <= 11             (eqn 1f)
##  0 <= z <= 13             (eqn 1g)
##  x, y, z is integer       (eqn 1h)

# Create variables to represent this problem
### define objective function (eqn 1a)
obj <- c(1, 2, 3)

## define constraint matrix (eqns 1c--1d)
A <- matrix(c(1, 1, 0, 3, 0, 4, 0, 0, 1), byrow = TRUE, nrow = 3)
print(A)

## note that we could also define the constraint matrix using a
## sparse format to reduce memory consumption
## (though not needed for such a small problem)
library(Matrix)
A_sp <- sparseMatrix(
  i = c(1, 2, 1, 2, 3),
  j = c(1, 1, 2, 3, 3),
  x = c(1, 3, 1, 4, 1))
print(A_sp)

## define upper and lower bounds for constraints (eqns 1c--1d)
row_ub <- c(1, Inf, 4)
row_lb <- c(-Inf, 5, 4)

## define upper and lower bounds for decision variables (eqns 1e--1g)
col_ub <- c(10, 11, 13)
col_lb <- c(0, 0, 0)

## specify which decision variables are integer (eqn 1h)
is_integer <- c(TRUE, TRUE, TRUE)

# Generate solution
## run solver (with default settings)
result <- cbc_solve(
  obj = obj, mat = A, is_integer = is_integer,
  row_lb = row_lb, row_ub = row_ub,
  col_lb = col_lb, col_ub = col_ub,
  max = TRUE)

## print result
print(result)

## extract information from result
objective_value(result) # objective value of solution
column_solution(result) # decision variable values in solution
solution_status(result) # status description

# Generate a solution with customized settings
## specify that only a single thread should be used,
## we only need a solution within 20\% of optimality,
## and that we can only 2 (wall clock) seconds for the solution
cbc_args <- list(threads = "1", ratio = "0.2", sec = "2", timem = "elapsed")

## run solver (with customized settings)
result2 <- cbc_solve(
  obj = obj, mat = A, is_integer = is_integer,
  row_lb = row_lb, row_ub = row_ub,
  col_lb = col_lb, col_ub = col_ub,
  max = TRUE, cbc_args = cbc_args)

## print result
## we can see that this result is exactly the same as the previous
## result, so these customized settings did not really any influence.
## this is because the optimization problem is incredibly simple
## and so \emph{CBC} can find the optimal solution pretty much instantly
## we would expect such customized settings to have an influence
## when solving more complex problems
print(result2)
}
}
\references{
Forrest J and Lougee-Heimer R (2005) CBC User Guide. In Emerging theory,
Methods, and Applications (pp. 257--277). INFORMS, Catonsville, MD.
\doi{10.1287/educ.1053.0020}.
}
\seealso{
\code{\link{objective_value}},
\code{\link{column_solution}},
\code{\link{solution_status}}.
}
