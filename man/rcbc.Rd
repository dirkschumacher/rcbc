% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rcbc-package.R
\docType{package}
\name{rcbc}
\alias{rcbc}
\title{\emph{CBC} bindings for R}
\description{
The \pkg{rcbc} package provides an interface to the
\href{https://projects.coin-or.org/Cbc}{\emph{CBC} (COIN-OR branchand cut)}
solver (Forrest & Lougee-Heimer 2005). Specifically, \emph{CBC} is an
open-source mixed integer programming solver that is developed as part of
the Computational Infrastructure for Operations Research (COIN-OR) project.
By interfacing with the \emph{CBC} solver, the \pkg{rcbc} package can be
used to generate optimal solutions to optimization problems (using the
\code{\link{cbc_solve}} function).
}
\examples{
\dontrun{
# Mathematically define a mixed integer programming problem
## maximize:
##   1 * x + 2 * y + 0.5 * z (eqn 1a)
## subject to:
##   x + y <= 1              (eqn 1b)
##   3 * x + 4 * z >= 5      (eqn 1c)
##   z = 4                   (eqn 1d)
##  0 <= x <= 10             (eqn 1e)
##  0 <= y <= 11             (eqn 1f)
##  0 <= z <= 13             (eqn 1g)
##  x, y, z is integer       (eqn 1h)

# Create variables to represent this problem
### define objective function (eqn 1a)
obj <- c(1, 2, 3)

## define constraint matrix (eqns 1c--1d)
A <- matrix(c(1, 1, 0, 3, 0, 4, 0, 0, 1), byrow = TRUE, nrow = 3)
print(A)

## note that we could also define the constraint matrix using a
## sparse format to reduce memory consumption
## (though not needed for such a small problem)
library(Matrix)
A_sp <- sparseMatrix(
  i = c(1, 2, 1, 2, 3),
  j = c(1, 1, 2, 3, 3),
  x = c(1, 3, 1, 4, 1))
print(A_sp)

## define upper and lower bounds for constraints (eqns 1c--1d)
row_ub <- c(1, Inf, 4)
row_lb <- c(-Inf, 5, 4)

## define upper and lower bounds for decision variables (eqns 1e--1g)
col_ub <- c(10, 11, 13)
col_lb <- c(0, 0, 0)

## specify which decision variables are integer (eqn 1h)
is_integer <- c(TRUE, TRUE, TRUE)

# Generate solution
## run solver (with default settings)
result <- cbc_solve(
  obj = obj, mat = A, is_integer = is_integer,
  row_lb = row_lb, row_ub = row_ub,
  col_lb = col_lb, col_ub = col_ub,
  max = TRUE)

## print result
print(result)

## extract information from result
objective_value(result) # objective value of solution
column_solution(result) # decision variable values in solution
solution_status(result) # status description

# Generate a solution with customized settings
## specify that only a single thread should be used,
## we only need a solution within 20\% of optimality,
## and that we can only 2 (wall clock) seconds for the solution
cbc_args <- list(threads = "1", ratio = "0.2", sec = "2", timem = "elapsed")

## run solver (with customized settings)
result2 <- cbc_solve(
  obj = obj, mat = A, is_integer = is_integer,
  row_lb = row_lb, row_ub = row_ub,
  col_lb = col_lb, col_ub = col_ub,
  max = TRUE, cbc_args = cbc_args)

## print result
## we can see that this result is exactly the same as the previous
## result, so these customized settings did not really any influence.
## this is because the optimization problem is incredibly simple
## and so \emph{CBC} can find the optimal solution pretty much instantly
## we would expect such customized settings to have an influence
## when solving more complex problems
print(result2)
}
}
\references{
Forrest J and Lougee-Heimer R (2005) CBC User Guide. In Emerging theory,
Methods, and Applications (pp. 257--277). INFORMS, Catonsville, MD.
\doi{10.1287/educ.1053.0020}.
}
\seealso{
\url{https://projects.coin-or.org/Cbc}.
}
\keyword{package}
